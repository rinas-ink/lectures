# Lecture 16

## [Не исключения](../16-220124/01-intermediate-exceptions/01-not-exception.cpp)

## [Гарании исключений](../16-220124/01-intermediate-exceptions/02-guarantees.cpp)

- Нужно, чтобы в функциях при исключении не было наушений инварианте, например утечек памяти. Плохо это `no_guarantee()`
  .

#### Базовая гарантия

- Инварианты не поменялись. Память не утекла.
    - Например, если вектор, то раскрутится вектор и вызовется деструктор.

#### Строгая гарантия

- Состояние программы после исключения не изменилось.

#### Нет исключений

- `void foo() noexcept {}`.
- В этой функции нельзя выделять память и выводить.
- Если [noexcept выкинула исключение](../), то рограмма сразу завершилась не вызвав детсрукторы.
- `std::terminate()` вызывает `std::abort()`, а он завершает программу и не вызовает деструкторы.

### [Исключение в деструкторе](../)

- Если к существующему присоединилось, то `std::terminate()`.
- В `c++03` если летит одно исключение, то все ок(удалятся все объекты), иначе прграмма завершится.
- В `c++11` по-умолчанию деструкторы `noexcept`.
- Единственный способ в `c++` кинуть 2 исключения - в деструкторах.

## [RAII](../)

1. Конструктор обеспечивает все инварианты. Если не получилось, то конструктор обязан выкинуть исключение.
2. Деструктор обязан освободить все ресурсы. Обычно под raii подразумевают только 2.

- Мы не обязательно поймаем исключение конкретно от инициализации. Но мы не можем получить доступ к переменной за
  пределами фигурных скобок `try`.
    - Можно внутрь засунуть `catch(...){}` чтобы отловить все остальное.
    - Можно как-то при помощи лямбд.

## Исключения между единицами трансляции

- Тут все работает даже если `main` не знает о классе исключения если оно наследник `exception`. Если какие-то
  трансляции сишные, то все плохо.

## Скорость работы исключений

- Если пометить `noexcept` или отключить в компиляторе, то быстро.
- `try / catch` без `throw` не замедляет программу.
- С исключениями в цикле мб в 1000 раз медленнее. Плохо использовать исключения при вызове функции.
- Нельзя сделать `goto` из функции наружу, поэтому не катит вместо исключений.

## Проблемы с исключениями в конструкторах

- Если мы кидаем исключение из конструктора, то исключение у текущего, еще не созданного объекта не вызовется. Время
  жизни объекта - после конструктора и до деструктора.

### У контейнеров

- Исключение при создании массива: удалятся элементы до того, в котором случилось исключение в конструкторе.
    - Но у вектора почему-то так не работает. Скорее всего это баг с `gcc`.
- У структуры тоже удалятся предыдущие созданные поля при исключении. Все хорошо даже когда `mamber intialization list`,
  т.к то что в `{}` выполныется после него.
- Если конструктор делегирующий и хотя бы один коонструктор завершился, то можно вызывать деструктор.
- При наследовании: порядок инциализации подобъектов определен, поэтому все ок. Порядок удаления обратен порядку
  создания.
    - Если уже сздали `Base`, то у него вызовется деструктор.

### В функциях

- При создании аргументов функции исколючение при вызове функции, она не начнет выполняться. Все ок, т.к после `c++-17`
  все аргументы создаются по-очереди.
- Если возвращаем по значению, то исключение в функции, его можно поймать в ней.
- Проблема с присваиванием `a = foo()`: если `foo` кинет исключение, то значение которое возвращаем уже потеряно. Поэтому так плохо.
    - Проблема с `pop`: оно не возвращает по значению, то там мб лажа.