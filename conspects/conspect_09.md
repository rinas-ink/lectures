### 03-move
- std::move(x) - не копирует x, а говорит, что можно портить, т.е перемещает.
- При возврате из ф-ции писать не нужно(почти всегда), т.к после выхода из ф-ции возвращаемое значение удаляется.

### 04-move-in-ctor
- Если unique_ptr в структуре
- make


### 03-linkage
- Можно определять ф-ции в .h, если написать inline - вставь код ф-ции в код, откуда вызывается. Т.е если компилятор встретит несколько ф-ций c inline, то вызовется только одна. Поэтому в единицах трнсляции должна быть ровно одна ф-ция с данным именем, иначе некорректная программа.
- может применяться к методам и ф-циям вне класса (если внутри структуры, то добавляется автоматически)
- Если вместо inline unnamed namespace, то у каждой ед. трансляции своя ф-ция.

## 09-211110

### 00-warnings
### 00b-
- Копирующий конструктор: создаем новый объект  
Foo c=a; - вызов конструктора
- Copy assignment operatir: Копируем в существующее  
Foo c;
c=a; - оператор присваивания.
- возвращается ссылка на объект

- Move constructur: Создаем новый и муваем
&& - ссылка присваивается только к временным объектам (возврат из ф-цииб иди из мува).
- Move assignment operator: Муваем в существующий
- Если перегружать, то перегружать сразу все и свраду деструктор.

### 01-basic
- Base - базовый(родиельский класс
- Derived - наследуемый. У него есть все public, protected поля и методы Base.
- protected - доступно насдедникам, друзьям, но не снаружи.

### 02-compatible
- В ссылку на Base, можно присвоить объект Derived. Туда скопируется все, что было в Base. Это basecast (upcast)
- То же с указателями
### 03-casts
- downcast - Base к Derived (если уверены, что он точно Derived, иначе UB).
- Если принимаем не по ссылке, а по значению: создается объект Base и туда копируются поля из Derived. Т.е нельза примести Base к Derived теперь.
- Derived м.б вызов конструктора Base. Сначала всегда проиничиализируется Base, потом поля Derived. Ключ -Wreorder
- Конструкторы, деструкторы, конструкторы копирования и перемещения не наследуются. Создаются автоматически в Derived.
### 10-no-polymorf
- Метод вызывается в зависимости от кого, что за обект на момент компиляции
### 11-naive-polymorf
- Если создаем поле ф-ции в родителе и ребенке, то вызываем ребенка, при присваивании ребенка родителю по ссылке.
- Но много памяти.
- [&] - запомни this по ссылке.
### 12-virtual
- помечаем virtual ф-цию в классе и наследниках. В наследниках обычно пишут override(проверяет, что в родителе virtual, и дописывает virtual) вместо этого. Тогда будет вызываться ф-ция из ребенка.
- независимо от кол-ва ф-ций память не растет.

### 13-pure-virtual
- Абстрактный класс содержит virtual int func() const =0
### 14-ptrs-bad
- Виртуальный декструктор- смотрим на реальный тип объекта. Всегда вместе с виртуальными ф-циями - иначе всегда UB.
