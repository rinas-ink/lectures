# Lecture 08-211020
### Explicit конструктор от многих аргументов ([code](../08-211020/00-extra/01-explicit-multiple-args.cpp))
- explicit можно помечать конструкторы от любого кол-ва аргументов. Тогда не будет работать копирующая инициализация.
- Копирующая инициализация при вызове функции и возвращении значения из нее. Поэтому с explicit не работает.

### 02-arifmetics. Арифметика указателей
- Распад массива в указатель. Получаем адрес первого элемента.
```cpp
sort(arr, arr+n)
```
- Указатели умеют работать только с массивом.
- Итераторы могут все.
#### Тонкости
- *r-- = *(r--), но x=*(r--) = *r
- *--r = *(--r), но x=*(--r) = *(r-1)
- Разность указателей: сколько нужно прибавить к одному, чтобы получить другой.
- В с++ обращение к массиву(к сишному) определено так. С вектором все ок.
```cpp
data[1] == *(data+1) == *(1+data) == 1[data]
```
### 03-arifmetics-borders
- Указатель на фиктивный элемент нельзя разыменовывать.
- Вылез за границы массива - UB

### 04-arifmetics-nits
- Вычитать можно только указателли на один массив. Иначе UB.
- Сравнивать можно, но возвращается рандом.
- Сравнивать на равенство можно всегда.
- Каждый элемент считается массивом из одного элемента, поэтому можно увеличивать любой указатель на 1. Но если разыменуем - UB.
- Можно сравнивать указатели на поля структуры - если оба private, оба public. Меньше тот, кто определен раньше.
- std::less - полный порядок на указателях. Совпадает с порядком если можно сравнить. Так можно создать множество указателей.

### 01-c-str
- Кусок байт(массив), в конце нуль терминатор \0.
- Есть перегрузки для вывода массивов символов. int* выведется указатель, char* - выведется массив. Выводится до пурвого терминатора.
- std::size(arr) - только от массива. От указателя не работает.
- static_cast<void*>(str) - указатель на что угодно.

### 02-arifmetics
- Когда ссылаемся на срочку (т.е константу).
```cpp
const char *s="hello"
// Нельзя char *s="hello"
```
### 03-compare
- Когда сравниваем сишные строки, сравниваем указатели на первые элементы(если они в общей строке) иначе рандом.
- == тоже рандом.
- Сравнивать нужно руками. Или str_cmp.

### 04-len
- Пробежать ручками или std::len = O(n).

### 05-allocator
- Чтобы не считать длину можно проверить, что текущий элемент не 0.
- Выделять память для суммы строк в функции нужно удалять память, т.к она динамическая. => нужно удалять
- Можно создать большой вектор, оттуда брать и его удалять сразу.
### 06-read-word
- Или функции сразу давать память.
- В stl есть gets(buf), Если буфера хватает, то ок, инче UB.
### 07-strings
- Сишная строка скопируется в string.
- s.c_str() - к сишной строке. Строка хранит указатель на последний 0, чтобы было легко так конвертировать.
- Может быть UB если стро

### 07-211013/.../07-dynamic
- Двойное удаление UB.
- Удаление рандомного элемента (automatic storaage duration вместо dinamic) - UB.
- Valgrind или -fsanitaze=adress - помогает это отлавливать.
  Valgrind --leak-check=true
### 07-211013/.../08-dynamic-syntax
- new int - без дефолтной инициализации
- delete не нужно знать размер массива.
### 01-basic.cpp
- Умные указатели. Они сразу удаляют то, на что указывают при удалении указателя. Они запрещают копировать. У каждого уазателя в нем один владелец.
### 03-move
- Можно перемещать из одного uniqptr в другой. Например, возвращать из функции. Или методом std::move(f).
### 04-move-in-ctor
- В конструкторе.
