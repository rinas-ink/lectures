# 13-211208
## 01-mi-virtual
### Множественное наследование ([code](../13-211208/01-mi-virtual/01-multiple-inheritance.cpp))
- Независимо создаются куски предков.
- Upcast не всегда невозможен.
- Вowncast не всегда возможен.
### Переапись в обих родителях ([code](../13-211208/01-mi-virtual/02-override-independent.cpp))
- Если в двух родителях виртуальная функция одинаково названа, то переопределение в наследнике перезапишет обе(если у них совместимые типы).
### 10-diamond-problem
- Нам не нравится, что в конструкторе MagicStudent нужно передавать его имя в обоих родителей. Хотим, чтобы самый базовый класс был для всех общий.
### 11-virtual-inheritage
- Виртуальное наследование. Когда наследуются виртуально, тородитель склеивается.
- Конструктор Person долже вызвать MagicStudent(у родителей он пропустится).
### Как виртуальное наследование реализовано ([code](../13-211208/01-mi-virtual/12-virtual-inheritance-naive.cpp))
- Проблема - не всегда можем взять ссылку на одного из родителей т.к в памяти не подряд.
### Реальное расположение в памяти ([code](../13-211208/01-mi-virtual/13-virtual-inheritance-impl.cpp))
-Создаем в VirtualEmployer и VirtStudent с указателями на Parent.
### Static_cast downcast ([code](../13-211208/01-mi-virtual/20-no-static-downcast.cpp))
- Не можем сдеалсть static_cast от виртуального базового т.к расстояние не фиксировано. Он должен на этапе компиляции понимать куда двигать.
### Dynamic downcast ([code](../13-211208/01-mi-virtual/20b-dynamic-downcast.cpp))
Но можем dynamic_cast, но нужно добавить в родителя виртуальную функцию.
### Доступ через многих родителей ([code](../13-211208/01-mi-virtual/21-most-accessible-path.cpp))
Компилятор выбирае наиболее простой путь к деду через родителя.
### Виртуальные функции 
- ([code](../13-211208/01-mi-virtual/22-mixins.cpp)) Виртуальные функции деда набирабираюся из обоих родителей.
- ([code](../13-211208/01-mi-virtual/23-no-unique-final-overrider.cpp)) Мб неоднозначно выбирать перезапись из родителей. Ошибка компиляции.
#### Delegate to sister ([code](../13-211208/01-mi-virtual/24-delegate-to-sister.cpp))
Если перезаписали

### Side Cast ([code](../13-211208/01-mi-virtual/25-side-cast.cpp))
Каст в бок. Спускается до реального типа а потом поднимается назад, чтобы было однозначно
### Смесь виртуального и нет ([code](../13-211208/01-mi-virtual/26-mixed.cpp))
- 

## 02-move-objects
### 01-move-faster-copy
- std::move - перемещвет значение, в исходном станет null.
- std::swap знает, что для векторов нужно тольлко поменять указатели. 
- Но это работает только с вектором. Будет работатьочень долго(в c++03) с оберткой-структурой S.
- В с++-11 swap работает так:
```c++
void swap(T&a, &b){
T tmp=std::move(a);
a=std::move(b)
b=std::move(a)
}
```
### 02-move-to-field
- Передача по значению - либо копирование, либо инициализация или мув(со временными).
### 03-moved-from-state
- У unique_ptr гарантируется nullptr после мува.
- После мува исходный объект портится (может остаться со старым значением, может обнулиться).

