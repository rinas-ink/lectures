# 10-211101
## Линковка с DLL
Линковка динамической библиотеки происходит во время компиляции в виндовс, а в линукс во время исполнения.

# 12-211201
## Меняем видимости методов родитея в наследнике
### Невиртуальныые перегрузки ([code](../12-211201/01-collisions/10-using-add-overload.cpp))
- Перегрузки ищутся только в самом классе, не предках.
- Можно просто перегрузить родителей
- Можно `using Base::foo` - добавятся все перегрузки с именами foo из родителя. Добавить однну перегрузку нельзя.
### Using чтобы менять уровень доступа ([code](../12-211201/01-collisions/11-using-change-access.cpp))
- Можно менять настройки доступа. Например в наследнике сделать публичной, когда в родителе протектед. Теперь из мэйна можем вызвать через потомка, но не через родителя. И вызывать из потомка.
- Но не можем так сделать если функция была приватной (к ней мы не имеем доступа из ребенка).
### Перезапись приватных виртуальных ([code](../12-211201/01-collisions/12-override-extend-access.cpp))
Виртуальные скрывают, но не перезаписывают.
- Если перезаписали приватную виртуальную функцию в публичности, то она станет публичной. Можем ее вызвать из ребенка. Но если мы не перезаписали виртуальную приватную, то вызвать не можем.
- Проверка типа происходит через то, что обращаемся.
### Наоборот ([code](../12-211201/01-collisions/13-override-shrink-access.cpp))
И можно наоборот - перезаписать публичными приватными, тогда не можем вызвать из наследника.
### Using Constructor ([one](../12-211201/01-collisions/14-using-ctor.cpp), ([two](../12-211201/01-collisions/15-using-ctor.cpp)))
- Конструкторы не наследуются.
- `using Base::Base` для конструкторов.
Конструктор ребенка всегда скрывает родителя. 
Добавятся все конструкторы из родителя(кроме приватных), но у них сохранятся настройки приватности. Если в ребенке пересечения с импортированными родительскими, то ребенок перекроет.
- В конструкторе ребенка всегда вызывается констр родителя (по умолчанию, если явно не пишем).
- Копирующая инициализация `Derived d = {1,2}`, не подходит если конструктор `explicit`.
### Специальные методы (5 штук)
([one](../12-211201/01-collisions/20-special-autogen.cpp), [two](../12-211201/01-collisions/21-special-protected.cpp), [three](../12-211201/01-collisions/22-special-base-private.cpp))
5 специальных методов:
```c++
Base(const Base &) = default; // Конструктор копирования
Base(Base &&) = default; // Перемещения
Base &operator=(const Base &) = default; // Оператор копирующего присваивания
Base &operator=(Base &&) = default; // перемещающего присваивания. && - не временный объект
~Base() = default; //Деструктор
```
Они генерируются в каждом классе автоматически. Если в базовом был, то в наследнике такие же, только дописаны еще присваивания чего-то.
- В наследнике они делаются публичными по умолчанию. Если эти методы в родителе приватные или `delete`, то в ребенке их не будет.

## 02-misc
### Вложенные структуры ([code](../12-211201/02-misc/01-nested-classes.cpp))
Вложенны структуры имеют доступ к полям того, куда вложен.
- `private` скрывает имена, поэтому нельзя создать объект вложенной структуры, которая в private.
- `auto` пофигу на видимость типов, может создать объект вложенной приватной структуры.
- Или можно создать публичный псевдоним приватной вложенной функции. `using get_struct = Nested`.
- `decl_type(func_name()) Nested;` - возвращает тип функции => можем создать объект типа возвращаемого значения. Т.е если фубличная функция возвращает приватный Nested то можем создать объект.
- Итераторы - nested классы.
### Скрытые функции-друзья ([code](../12-211201/02-misc/02-hidden-friends.cpp))
Друга можно объявить и определить в самом классе и в private/public поле. Друзьям пофиг на это, она внешняя для класса сущность.
- Если функция-друг и объявлена и определена в классе, то тогда она скрытый друг и ищется только через ADL.
- Если определили вне класса, то можем вызывать кваливфицированно.
#### ADL - argument dependent lookup.
- Компилятор ищет функцию в том числе через аргуметы (например функция м.б. в классе и аргумент- класс => найдется). Даже определенные в привате найдутся.
- Но в квалифицированный вызов не найдет друзей из привата.
### Структура-друг ([code](../12-211201/02-misc/03-friend-struct.cpp))
- Другом м.б структура.
### Структура-друг из другогонэймспейса ([code](../12-211201/02-misc/04-friend-struct-other-namespace.cpp))
Если друг из другого нэймспэйса, то нужно вызывать квалифицированно.
### Функция-друг из другогонэймспейса ([code](../12-211201/02-misc/05-friend-make-unique-bad.cpp))
Можно делать френдом ф-цию из другого нэймпэйса. Но эта ф-ция может вызывать нефрэнды, которые захотят обратиться к текущему объекту => может упасть.
- Вместо этого делают такую функцию
```c++
struct Foo(){
    static std::unique_ptr<Foo> make() {
        return std::unique_ptr<Foo>(new Foo());  // good
    }}
```

## Сущности внутри класса с именами
### Какие имена м.б в стуктурах. ([code](../12-211201/03-access-specifiers/01-class-members.cpp))
- Статические методы могут обращаться только к статическим полям.
- У нестатических есть неявный арумент this.
- `emun class` примерно namespace
```c++
typedef int myInt1;
using MyInt2 = int;
```
- private/public/protected не влияет на френды и конструкторы.
### 02-choose, 3
- В файле написан порядок доступа. Проверку доступности в последнюю очередь.
- Проверяется доступ именно к имени.
### 04
Метод живет  в классе, не смотря откуда обратились. Если обращаемся(к приватному) в родилеле, но квалифицированно через наследника, то все равно будет ОК.
### 10, 11
- К private чего-то могу обращаться только если внутри того же класса.
- Дружба не наследуется.
### 12-protected
- Из родителя нет доступа к protected в наследниках.
- Дети друг про друга ничего не знают.
- Ссылки и указатели отрубают этот доступ.
- Непонятно имеет ли друг ребенка доступ к защищенным полям родителя (с 17 стандарта не имеет, до имеет, но компиляторы не могут договориться).


