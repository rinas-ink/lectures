# 10-211101
## 04
Линковка динамической библиотеки происходит во время компиляции в виндовс, а в линукс во время исполнения.

# 12-211201
## 01-colisions
### 10
- Перегрузки ищутся только в самом классе, не предках.
- Можно просто перегрузить родителей
- Можно `using Base::foo` - добавятся все перегрузке из родителя.
### 11
- Можно менять настройки доступа. Например в наследнике сделать публичной, когда в родителе протектед. И вызывать из потомка.
- Но не можем так сделать если функция была приватной (к ней мы не имеем доступа из ребенка).
### 12
Виртуальные скрывают, но не перезаписывают.
Если перезаписали приватную виртуальную функцию в публичности, то она станет публичной. Можем ее вызвать из ребенка.
Но если мы не перезаписали виртуальную приватную, то вызвать не можем.
Проверка типа происходит через то, что обращаемся.
### 13
И можно наоборот - перезаписать публичными приватными, огда не можем вызвать из наследника.
### 14, 15
`using Base::Base` для конструкторов.
Конструктор ребенка всегда скрывает родителя. Конструкторы просто н енаследуются.
Добавятся все конструкторы из родителя(кроме приватных), но у них сохранятся настройки приватности. Если в ребенке пересечения с импортированными родительскими, то ребенок перекроет.
В конструкторе ребенка всегда вызывается констр родителя (по умолчанию, если явно не пишем).

Копирующая инициализация `Derived d = {1,2}`, не подходит если конструктор `explicit`.
### 20-22
5 специальных методов:
- копирования/перемещения
- присвания / присваивания мувом
- деструктор
Они генерируются в кадлом классе автоматически. Если в базовом был, то в наследнике такие же, только дописаны еще присваивания чего-то.
В наследнике они лелаются публичными по умолчанию.
Если эти методы в родителе приватные или `delete`, то в ребенке их не будет.

## 02-misc
### 01-nested
Вложенны структуры имеют доступ к полям того, куда вложен.
`auto` пофигу на видимость типов. `private` скрывает имена, поэтому нельзя создать объект вложенной структуры, которая в private.
`decl_type(func_name())` - возвращает тип функции.
- Итераторы - nested классы.
### 02-hidden-friends
Друга можно объявить и определить в самом классе и в private/public поле.
#### ADL - argument dependent lookup.
- Компилятор ищет функцию в том числе через аргуметы (например функция м.б. в классе и аргумент- класс => найдется). Даже определенные в привате найдутся.
- Но в квалифицированный вызов не найдет друзей из привата.
### 03-friend-structб 
- Другом м.б структура.
### 04
Если друг из другого нэймспэйса, то нужно вызывать квалифицированно.
### 05
Можно делать френдом ф-цию из другого нэймпэйса, но эта ф-ция может вызывать нефрэндом => может упасть.

## 03
### 01-class-members Какие имена м.б в стуктурах.
- Статические методы могут обращаться только к статическим полям.
- У нестатических есть неявный аврумент this.
- `emun class` примерно namespace
### 02-choose, 3
- В фаыйле написан порядок доступа. Проверку доступности в последнюю очередь.
- Проверяется доступ именно к имени.
### 04
Метод живет  в классе, не смотря откуда обратились. Если обращаемся(к приватному) в родилеле, но квалифицированно через наследника, то все равно будет ОК.
### 10, 11
- К private чего-то могу обращаться только если внутри того же класса.
- Дружба не наследуется.
### 12-protected
- Из родителя нет доступа к protected в наследниках.
- Дети друг про друга ничего не знают.
- Ссылки и указатели отрубают этот доступ.
- Непонятно имеет ли друг ребенка доступ к защищенным полям родителя (с 17 стандарта не имеет, до имеет, но компиляторы не могут договориться).


