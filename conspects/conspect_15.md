# Lecture 15, Исключения и обработка ошибок

## Виды ошибок

[статья](../15-220117/01-ideology/README.md)

## Ошибки чтения файлов

### [Проверка файла](../15-220117/02-error-techniques/01-object-state-flag.cpp)

- Про bad / fail / eofbit: [cppref](https://en.cppreference.com/w/cpp/io/ios_base/iostate). Их комбинация
  образует `operator bool`.
    - `failbit` - считать не получилось.
    - `badbit`- невозможно продолжить считывать(например, вынули флешку).
- Нужно проверять, что файл открыт.

### [Сишный способ проверки](../15-220117/02-error-techniques/02-global-errno.cpp)

- `errno` - макрос, отображает статус работы программы, в данном примере статус открытия файла(?). Проблема в том, что
  нужно проверять это макрос сразу после возможной ошибки, т.к он обновляется.

### [Пример, как в базах данных](../15-220117/02-error-techniques/03-retval.cpp)

- Всегда возвращаем код ошибки, если нужно вернуть что-то другое передаем буфер`&db`.

### Мы обязаны обработать ощибки - Rust

[пример](../15-220117/02-error-techniques/04-either.rs)  
[синтаксический сахар](../15-220117/02-error-techniques/05-either-syntax-sugar.rs)

## Как обрабатывать ошибки?

1. Никак. Assert в release убираются. [assert](../15-220117/02-error-techniques/10-no-handling.cpp).
2. `if` и `std::exit(1)`. [code](../15-220117/02-error-techniques/11-handle-in-place.cpp).
3. Возвращать наверх. [code](../15-220117/02-error-techniques/12-propagate.cpp).

## Исключения

### Синтаксис

(01-basic.cpp)

- `throw exception_obj()` - бросаем исключение. Компилятор ищет ближайший `try-catch`, передавая созданный при `throw`
  объект дальше.
- Базового типа исключений, нет. Можно кидать почти любой тип, но не всегда хорошо.
- Не знаем(легко), откуда конкретно вылетела ошибка.
- Мб много `catch`. Они выполняются сверху вниз, можно обработать только одну ошибку.  
  (02)
- `catch(...)` -поймай что угодно. Ловит только исключения.  
  (03)
- `catch` требует точного совпадения типов(нет неявных преобразований), но можно наследование. Можно по ссылкам. Нельзя
  даже кинуть инт и поймать как добл.
- Все деструкторы всех переменных при исключении корректно вызываются, не будет утечек памяти.

### Вложенные try-catch (04-..)

- Нет блока `finally`.
- После исключения остальной код блока `try` не выполняется.
- Если выбрасываем в `try`, то смотрим, на принадлежащие ему `catch`, если в `catch` то нет.

### Необработанные исключения

- Исключение вылетает из мэйна. Компилятор имеет право не вызвать деструкторы, гарантируется, что программа завершится.
- `catch(...){ throw;}` - перебрось текущее исключение.
- Все шаблонные типы разные.

### Стандартные исключения

- Наследуются `std::exception`. Есть опреатор `what()`, который возвращает сишную стороку(чтобы не выделять память на
  всякий) с информацией.
- Чтобы наследоваться от `std::exception` нужно перезаписать `what()`.
- `noexcept` - запрещает функции кидать исключение.
- Но лучше наследоваться от `logic_error` (ошибки программирования) или `runtiome_error` (окружения). Там можно вызвать
  контруктор `runtime_error` от строчки, он сам ее обработает и выведет.
- Можно при помощи `boost` выводить с backtrace.