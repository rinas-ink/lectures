# Lecture 15, Исключения и обработка ошибок

## [Виды ошибок](../15-220117/01-ideology/README.md)

## Ошибки чтения файлов

### [Проверка файла](../15-220117/02-error-techniques/01-object-state-flag.cpp)

- Про bad / fail / eofbit: [cppref](https://en.cppreference.com/w/cpp/io/ios_base/iostate). Их комбинация
  образует `operator bool`.
    - `failbit` - считать не получилось.
    - `badbit`- невозможно продолжить считывать(например, вынули флешку).
- Нужно проверять, что файл открыт.

### [Сишный способ проверки](../15-220117/02-error-techniques/02-global-errno.cpp)

- `errno` - макрос, отображает статус работы программы, в данном примере статус открытия файла(?). Проблема в том, что
  нужно проверять это макрос сразу после возможной ошибки, т.к он обновляется.

### [Пример, как в базах данных](../15-220117/02-error-techniques/03-retval.cpp)

- Всегда возвращаем код ошибки, если нужно вернуть что-то другое передаем буфер`&db`.

### Мы обязаны обработать ощибки - Rust

[пример](../15-220117/02-error-techniques/04-either.rs)  
[синтаксический сахар](../15-220117/02-error-techniques/05-either-syntax-sugar.rs)

## Как обрабатывать ошибки?

1. Никак. Assert в release убираются. [assert](../15-220117/02-error-techniques/10-no-handling.cpp).
2. `if` и `std::exit(1)`. [code](../15-220117/02-error-techniques/11-handle-in-place.cpp).
3. Возвращать наверх. [code](../15-220117/02-error-techniques/12-propagate.cpp).

## Исключения

### Синтаксис

#### [Basic](../15-220117/03-basic-exceptions/01-basic.cpp)

- `throw exception_obj()` - бросаем исключение. Компилятор ищет ближайший `try-catch`, передавая созданный при `throw`
  объект дальше.
- Базового типа исключений, нет. Можно кидать почти любой тип, но не всегда хорошо.
- Не знаем(легко), откуда конкретно вылетела ошибка.
- Мб много `catch`. Они выполняются сверху вниз, можно обработать только одну ошибку.

#### [With destructors](../15-220117/03-basic-exceptions/01b-destructors.cpp)

- `catch(...)` -поймай что угодно. Ловит только исключения.

#### [Много catch](../15-220117/03-basic-exceptions/02-multiple-catch.cpp) и [Ловим наследников](../15-220117/03-basic-exceptions/03-catch-inheritance.cpp).

- `catch` требует точного совпадения типов(нет неявных преобразований), но можно наследование. Можно навесить `const`,
  ссылочность. Нельзя даже кинуть `int` и поймать как `double`. -Нужно ловить по ссылке иначе `slicing`.
- Все деструкторы всех переменных при исключении корректно вызываются, не будет утечек памяти.

#### [Сильно вложенные try-catch](../15-220117/03-basic-exceptions/04-complex-try-block.cpp)

- В `c++` нет блока `finally`.
- После исключения остальной код блока `try` не выполняется.
- Если выбрасываем в `try`, то смотрим, на принадлежащие ему `catch`, если подходящих `catch` нет, то выше.

### [Необработанные исключения](../15-220117/03-basic-exceptions/05-uncaught.cpp)

- Исключение вылетает из мэйна. Компилятор имеет право не вызвать деструкторы, гарантируется, что программа завершится.
- `catch(...){throw;}` - перебрось текущее исключение.
- Все шаблонные типы разные, могут не пойматься `catch`.

### [Стандартные исключения](../15-220117/03-basic-exceptions/10-std-exceptions.cpp) и [Наследованные от стандартных](../15-220117/03-basic-exceptions/11-inherit.cpp)

- Наследуются `std::exception` в библиотеке `exception`. Есть оператор `what()`, который возвращает сишную стороку(чтобы
  не выделять память на всякий) с информацией.
- Чтобы наследоваться от `std::exception` нужно перезаписать `what()`.
- `noexcept` - запрещает функции кидать исключение.
- Но лучше наследоваться от `logic_error` (ошибки программирования) или `runtiome_error` (окружения).
    - Там можно вызвать контруктор `runtime_error` от строчки, он сам ее обработает и выведет.
- Можно при помощи `boost` выводить с backtrace.
- Можно отрубить исключения в программе `-fno-exceptions`.
- Если делаьть `dunamic_cast` к ссылке и не смочь, то вместо `nullptr` будет исключение.