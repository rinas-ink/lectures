# 01-padding
- `size of(Foo)` - размер в памяти
- Адрес int должен делиться на 4. Можно узнать, какой отступ у разных типов: `alignof(Foo)`. Любое требование на выравниваение - степень 2.
- Выравниваение структуры - максимум из выравнивание ее элементов.
- Компилятор считает ссылку char* строкой и выводит как строку. Поэтому нужно `static_cast<void*>`.
# 10-naive-polymorf
- Как реализованы виртуальные функции, чтобы размер не раздувался как в этом файле?
`std::function<void()> print=[&](){}`; // & - запомни место расположения => можно обращаться ка внешним переменным.
# 11-fptrs
- `using my_func_ptr = void(*)(Base*)`
- Создаем указатель на функцию, в наследниках перезаписываем.
- Все еще память растет линейно с кол-вом объектов.
# 12-vtable ([code](../11-211124/01-struct-internals/12-vtable.cpp))
- Создаем одну большую таблицу `Vtable` c функциями структуры. В структуре создаем static переменую этой таблицы. Если нужно в наследниках перезаписываем. `virtual` работает примерно так.
# 13-vtable-inheritage ([code](../11-211124/01-struct-internals/13-vtable-inheritance.cpp))
- Чтобы наследнику добавить еще виртуальных методов, можно сделать наследник `Derived_Vtable`.
- `static_cast<DerivedVtable*>(vtable) -> func_of_deriver` - это пишем в наследнике.
- Вызовы виртуальных функций медленнее обычных - идет к структуре, там идет к таблице, потом запускает.

# 02-shared-library
## Глобальные переменные в DLL ([code](../11-211124/02-shared-library/01-static-storage))
- `BOOST_SYMBOL_VISIBLE` - ф-ция, которая и в dll и в main.
- static внутри ф-ции - общая на все функции.
- В main загружаем плагин: `boost::shared_ptr...`
- `boost::dll::load_more::append_decorations` - добавь к названию, которое ищешь разные штуки, которые принять добавлять в разных ОС к ним.
- Глобальные переменные в main и plugin разные т.к создаютя одни на программу(одна программа в exe  одна в dll). 
- Могут быть копии static в exe и dll из-за этого проблемы.
- Так же м.б проблемы с аллокацией, т.к у dll своя куча с памятью.
## DLL владеет vtable объекта, которого создала ([code](../11-211124/02-shared-library/02-ownership))
- boost::shared_ptr - можно копировать и мувать. Объект удаляются, когда умирают все указатели.
- Плагин создает наследника и таблицу виртуальных функций у себя. Когда умирает плагин умирает и таблица. 
- Нужно следить, чтобы плагин жил на момент использования. Сделать глобальным.
## Ошибки с STL ([code](../11-211124/02-shared-library/03-stdlib-mismatch))
- Если стандартная библиотека скомпилирована под разными компиляторами, то у нее мб разный ABI (например занимает разное место в памяти). Из-за этого плагин может не смочь принять строку из мэйна.
# 03-collisions
## Перекрывание ([code](../11-211124/03-collisions/01-access-specific.cpp))
- Не виртуальность, все методы остаются.
- Обратиться к методу родителя `d.Base::foo()`. Если в ребенке и родителе есть перекрывание.
## Виртуальность ([code](../11-211124/03-collisions/02-access-specific-virtual.cpp))
- Вызывать виртуальную так же как и при перекрывании, виртуальность отрубается.
## Если в базавом была число виртуальная ([code](../11-211124/03-collisions/03-access-specific-pure-virtual.cpp))
- Если в родителе чисто виртуальная - ошибка линковки.
- Можно избежать если определить вне класса(но не надо). Но Base все еще останется абстрактным.
- Т.е можно определять чисто виртуальные функции.
## Виртуализируем функцию в наследнике ([code](../11-211124/03-collisions/04-make-virtual.cpp))
- Если виртуальная перезаписывает обычную в наследнике: вызвать начальную версию можно либо по ссылке на Base либо по квалифицированно.
## Перегрузки в базовом и наследнике ([code](../11-211124/03-collisions/10-using-add-overload.cpp))
- Если перегрузка ф-ции перекрывает несколько перегрузок. Берутся все перегрузки из ребенка, на родителя не смотрят.
